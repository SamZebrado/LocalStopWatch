<!-- stopwatch.html ä¸»é¡µé¢ -->
<!DOCTYPE html>
<html lang="zh">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta charset="UTF-8">
  <title>æœ¬åœ°ç½‘é¡µç§’è¡¨</title>
  <script>
// timer.js

let t_Initial = Number(localStorage.getItem('t_Initial')) || Date.now();
let t_Last = Number(localStorage.getItem('t_Last')) || t_Initial;
let intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
let logs = JSON.parse(localStorage.getItem('logs') || '[]');

function pad(n, z = 2) { return ('00' + n).slice(-z); }

function formatTime(ms) {
  let totalSeconds = Math.floor(ms / 1000);
  let hours = Math.floor(totalSeconds / 3600);
  let minutes = Math.floor((totalSeconds % 3600) / 60);
  let seconds = totalSeconds % 60;
  let fraction = Math.floor((ms % 1000));
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${String(fraction).padStart(3, '0')}`;
}

function formatDateWithTimezone(date) {
  const dateStr = date.toLocaleString(undefined, { timeZoneName: 'short' });
  const ms = String(date.getMilliseconds()).padStart(3, '0');
  return `${dateStr}.${ms}`;
}

function exportIntervalsToCSV() {
  if (!intervals.length) {
    alert(getI18n('noRecords'));
    return;
  }

  const rows = [
    ['æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰', 'æ ¼å¼åŒ–æ—¶é—´', 'å¤‡æ³¨', 'æ ‡ç­¾', 'ç»“æŸæ—¶é—´']
  ];

  intervals.forEach(item => {
    const mins = item.durationMs ? (item.durationMs / 60000).toFixed(2) : '';
    const endTimeStr = formatDateWithTimezone(new Date(item.endTime));
    rows.push([
      mins,
      item.duration || '',
      item.memo || '',
      item.tag || '',
      endTimeStr
    ]);
  });

  const csv = rows.map(row => row.map(val => `"${val}"`).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');

  const now = new Date();
  const filename = `${now.toLocaleTimeString().replace(/:/g, 'ï¼š')} ${now.toLocaleDateString()} ${Intl.DateTimeFormat(undefined, { timeZoneName: 'short' }).format(now).split(' ').pop()}.csv`;

  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function updateDisplay() {
  const now = Date.now();
  const elapsed = now - t_Last;

  document.getElementById('current-duration').textContent = formatTime(elapsed);
  document.getElementById('absolute-time').textContent = new Date(now).toLocaleTimeString();
  document.getElementById('absolute-date').textContent = new Date(now).toLocaleDateString();
  document.getElementById('initial-time').textContent = new Date(t_Initial).toLocaleTimeString();
  document.getElementById('initial-date').textContent = new Date(t_Initial).toLocaleDateString();

  requestAnimationFrame(updateDisplay);
}

function renderIntervals() {
  const container = document.getElementById('intervals-container');
  container.innerHTML = '';

  intervals.slice().reverse().forEach((item, index) => {
    const trueIndex = intervals.length - 1 - index;
    const div = document.createElement('div');
    div.className = 'interval-record';
    const mins = item.durationMs ? (item.durationMs / 60000).toFixed(2) : '--';
    const endTimeStr = formatDateWithTimezone(new Date(item.endTime));
    div.innerHTML = `
      <div><strong class="duration">${mins} åˆ†é’Ÿ</strong></div>
      <div>Tag: <input value="${item.tag || ''}" oninput="updateTag(${trueIndex}, this.value)"></div>
      <div>Memo: <input value="${item.memo}" oninput="updateMemo(${trueIndex}, this.value)"></div>
      <div>æŒ‡å®šæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰: <input type="number" value="${item.setDuration || ''}" oninput="updateSetDuration(${trueIndex}, this.value)"></div>
      <div>ç»“æŸæ—¶é—´: ${endTimeStr}</div>
      <button onclick="parseMemo(${trueIndex})">è§£æMemo</button>
      <button onclick="undoParse(${trueIndex})">æ’¤é”€</button>
    `;
    if (item.parsed) div.style.background = '#eee';
    container.appendChild(div);
  });
}

function rememberInterval() {
  const now = Date.now();
  const localCopy = JSON.parse(localStorage.getItem('intervals') || '[]');
  if (localCopy.length > intervals.length) {
    alert(getI18n('outdatedWarning'));
    return;
  }

  const durationMs = now - t_Last;
  const memo = document.getElementById('memo-input').value.trim();

  const item = {
    memo,
    tag: '',
    duration: formatTime(durationMs),
    durationMs,
    endTime: now,
    setDuration: '',
    originalMemo: memo,
    parsed: false
  };

  intervals.push(item);
  localStorage.setItem('intervals', JSON.stringify(intervals));

  document.getElementById('memo-input').value = '';

  t_Last = now;
  localStorage.setItem('t_Last', t_Last);
  renderIntervals();
}

function updateTag(index, value) {
  intervals[index].tag = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function updateMemo(index, value) {
  intervals[index].memo = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function updateSetDuration(index, value) {
  intervals[index].setDuration = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function resetTimer() {
  t_Initial = Date.now();
  t_Last = t_Initial;
  localStorage.setItem('t_Initial', t_Initial);
  localStorage.setItem('t_Last', t_Initial);
}

function updateLogDisplay() {
  const logText = logs.map(l => `ã€${l.type}ã€‘${l.time}`).join('\n---\n');
  document.getElementById('log-content').textContent = logText;
}

function refreshLog() {
  logs = logs.filter(l => l.type !== 'Interval');
  intervals.forEach(item => {
    logs.push({
      type: 'Interval',
      time: formatDateWithTimezone(new Date(item.endTime))
    });
  });
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
}

function clearLog() {
  logs = [];
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
}

function copyLog() {
  navigator.clipboard.writeText(document.getElementById('log-content').textContent);
}


function toggleInitialTime() {
  const section = document.getElementById("initial-time-section");
  const btn = document.getElementById("toggle-initial-time-btn");
  const isHidden = section.style.display === "none";
  section.style.display = isHidden ? "block" : "none";
  btn.textContent = isHidden ? "éšè—ç¬¬ä¸€ä¸ªå¼€å§‹æ—¶é—´" : "æ˜¾ç¤ºç¬¬ä¸€ä¸ªå¼€å§‹æ—¶é—´";
}

window.onload = () => {
  updateDisplay();
  renderIntervals();
  logs.push({ type: 'åˆ·æ–°', time: formatDateWithTimezone(new Date()) });
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
};



// ===  å…¨å±€å¤šè¯­è¨€æç¤ºè¡¨ ===
const i18n = {
  noRecords: {
    zh: 'æ²¡æœ‰è®°å½•å¯å¯¼å‡º',
    mix: 'æ²¡æœ‰è®°å½•å¯å¯¼å‡º',
    en: 'No records to export'
  },
  outdatedWarning: {
    zh: 'âš ï¸ å½“å‰é¡µé¢ä¸æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè®°å½•å·²è¢«å…¶ä»–æ ‡ç­¾é¡µä¿®æ”¹ï¼Œè¯·åˆ·æ–°åå†å°è¯•ã€‚',
    mix: 'âš ï¸ å½“å‰é¡µé¢ä¸æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè®°å½•å·²è¢«å…¶ä»–æ ‡ç­¾é¡µä¿®æ”¹ï¼Œè¯·åˆ·æ–°åå†å°è¯•ã€‚',
    en: 'âš ï¸ This page is outdated. Records have been updated in another tab. Please refresh and try again.'
  },
  manualBackupSaved: {
    zh: 'âœ… æ‰‹åŠ¨å¤‡ä»½å·²ä¿å­˜',
    mix: 'âœ… æ‰‹åŠ¨å¤‡ä»½å·²ä¿å­˜',
    en: 'âœ… Manual backup saved'
  },
  noBackup: {
    zh: 'æš‚æ— å¤‡ä»½',
    mix: 'æš‚æ— å¤‡ä»½',
    en: 'No backups found'
  },
  csvImportError: {
    zh: 'âŒ CSVæ ¼å¼é”™è¯¯ï¼Œå¯¼å…¥å¤±è´¥',
    mix: 'âŒ CSVæ ¼å¼é”™è¯¯',
    en: 'âŒ Invalid CSV format'
  },
    parseFailed: {
    zh: 'âŒ è§£æå¤±è´¥ï¼šæ‰¾ä¸åˆ°å¯¹åº”çš„è®°å½•ã€‚',
    mix: 'âŒ è§£æå¤±è´¥ï¼šæ‰¾ä¸åˆ°å¯¹åº”çš„è®°å½•ã€‚',
    en: 'âŒ Parsing failed: item not found.'
  },
  undoFailed: {
    zh: 'âš ï¸ æ— æ³•æ’¤é”€ï¼šè¯¥è®°å½•æœªè¢«è§£æã€‚',
    mix: 'âš ï¸ æ— æ³•æ’¤é”€ï¼šè¯¥è®°å½•æœªè¢«è§£æã€‚',
    en: 'âš ï¸ Cannot undo: this item was not parsed.'
  },
    ruleHelp: {
    zh: `
è§„åˆ™è¯´æ˜ï¼š

1. ç¬¬ä¸€è¡Œæ˜¯æ ‡ç­¾åï¼ˆTagï¼‰ï¼Œå¯ç‚¹å‡»ç¼–è¾‘ï¼›
2. æ¯åˆ—ä¸ºä¸€ä¸ªæ ‡ç­¾ï¼Œä¸‹é¢å¡«å†™è¯¥æ ‡ç­¾çš„å…³é”®å­—ï¼›
3. ç²¾ç¡®åŒ¹é…ï¼Œå¤§å°å†™æ•æ„Ÿï¼›
4. è‹¥å…³é”®å­—å‰åŠ  ~ è¡¨ç¤ºâ€œå¤‡æ³¨ä¸­ä¸åŒ…å«è¯¥è¯â€æ—¶åŒ¹é…ï¼›
5. æ ‡ç­¾çš„åŒ¹é…é¡ºåºä»å·¦åˆ°å³ï¼Œæ‰¾åˆ°ä¸€ä¸ªåŒ¹é…å°±ä¼šåœæ­¢ï¼›
6. æ„Ÿå¹å·å¼€å¤´çš„å…³é”®è¯ï¼ˆå¦‚ !spï¼‰ä¼šä¸¥æ ¼åŒ¹é…å¹¶ä» Memo ä¸­åˆ é™¤ï¼Œä¸”ä»…åœ¨ Memo æœ«å°¾éƒ¨åˆ†ç”Ÿæ•ˆï¼›
7. é»˜è®¤ä¼šæ¸…é™¤åŒ¹é…çš„å…³é”®è¯ï¼Œä½†ä½ å¯ä»¥é€šè¿‡æ„Ÿå¹å·å‰ç¼€æˆ–å¦å®šå…³é”®è¯ä¿ç•™ç‰¹å®šçš„åŒ¹é…é¡¹ï¼›
8. å¤‡ä»½è§„åˆ™å¯ä»¥é€šè¿‡ CSV å¯¼å…¥æˆ–å¯¼å‡ºè¿›è¡Œæ“ä½œã€‚
    `,
    mix: `
Rule Explanation:

1. The first row is for the tag names (Tag), editable;
2. Each column represents a tag, with keywords listed below each tag;
3. Exact matching, case-sensitive;
4. Keywords prefixed with ~ match when the word is not present in Memo;
5. Tags are matched from left to right, and matching stops once a keyword is found;
6. Keywords starting with ! (e.g., !sp) will strictly match and remove the keyword from the end of the Memo only;
7. By default, matched keywords are removed, but you can preserve specific matches by using the exclamation mark or the negation keyword;
8. Backup rules can be imported or exported via CSV.
    `,
    en: `
Rule Explanation:

1. The first row is for the tag names (Tag), editable;
2. Each column represents a tag, with keywords listed below each tag;
3. Exact matching, case-sensitive;
4. Keywords prefixed with ~ match when the word is not present in Memo;
5. Tags are matched from left to right, and matching stops once a keyword is found;
6. Keywords starting with ! (e.g., !sp) will strictly match and remove the keyword from the Memoâ€™s end, only for the last part;
7. By default, matched keywords are removed, but you can preserve specific matches using the exclamation mark or negation keyword;
8. Backup rules can be imported or exported via CSV.
    `
  }
};

function getI18n(key) {
  const lang = window.currentLang || 'zh';
  return (i18n[key] && i18n[key][lang]) || i18n[key]?.zh || '';
}

// === 1. æ˜¾ç¤ºæ‰€æœ‰å¤‡ä»½åˆ—è¡¨ ===
function listAllBackups() {
  const container = document.getElementById('backup-list');
  container.innerHTML = '';
  const allKeys = Object.keys(localStorage).filter(k => k.startsWith('intervals_manual_') || k.startsWith('intervals_auto_'));
  if (allKeys.length === 0) {
    container.innerHTML = `<p>${getI18n('noBackup')}</p>`;
    return;
  }
  allKeys.sort();
  allKeys.reverse();
  allKeys.forEach((key, i) => {
    const div = document.createElement('div');
    div.innerHTML = `${i + 1}. ${key} <button onclick="exportBackupToCSV('${key}')">å¯¼å‡ºCSV</button>`;
    container.appendChild(div);
  });
}

// === 2. æ‰‹åŠ¨å¤‡ä»½åŠŸèƒ½ ===
function triggerManualBackup() {
  const keyPrefix = 'intervals_manual_';
  const all = Object.keys(localStorage).filter(k => k.startsWith(keyPrefix));
  all.sort();
  if (all.length >= 3) {
    const oldest = all[0];
    localStorage.removeItem(oldest);
  }
  const now = new Date().toISOString().replace(/[:.]/g, '-');
  const current = JSON.parse(localStorage.getItem('intervals') || '[]');
  localStorage.setItem(`${keyPrefix}${now}`, JSON.stringify(current));
  listAllBackups();
  alert(getI18n('manualBackupSaved'));
}

// === 3. å¯¼å…¥CSVä¸ºintervalæ•°æ® ===
function importBackupFromCSV() {
  const fileInput = document.getElementById('import-backup-file');
  const file = fileInput.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function (e) {
    const text = e.target.result;
    const lines = text.trim().split('\n');
    const header = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
    const idx = name => header.indexOf(name);
    const result = [];
    for (let i = 1; i < lines.length; i++) {
      const cells = lines[i].split(',').map(s => s.replace(/^"|"$/g, ''));
      result.push({
        duration: parseFloat(cells[idx('Duration')]) * 60000,
        memo: cells[idx('Memo')] || '',
        tag: cells[idx('Tag')] || '',
        setDuration: cells[idx('SetDuration')] || '',
        endTime: cells[idx('EndTime')] || new Date().toISOString(),
        parsed: true
      });
    }
    localStorage.setItem('intervals', JSON.stringify(result));
    location.reload();
  };
  reader.readAsText(file);
}

document.addEventListener('DOMContentLoaded', () => {
  listAllBackups(); // é¡µé¢åŠ è½½åå±•ç¤ºå¤‡ä»½åˆ—è¡¨
});

function restoreLatestBackup() {
  // è·å–æ‰€æœ‰å¤‡ä»½ï¼ˆæ‰‹åŠ¨å¤‡ä»½æˆ–è‡ªåŠ¨å¤‡ä»½ï¼‰
  const backupKeys = Object.keys(localStorage).filter(key => key.startsWith('intervals_manual_') || key.startsWith('intervals_auto_'));

  if (backupKeys.length === 0) {
    alert('æ²¡æœ‰æ‰¾åˆ°å¤‡ä»½');
    return;
  }

  // åˆ›å»ºå¯¹è¯æ¡†å®¹å™¨
  const dialog = document.createElement('div');
  dialog.style.position = 'fixed';
  dialog.style.top = '50%';
  dialog.style.left = '50%';
  dialog.style.transform = 'translate(-50%, -50%)';
  dialog.style.backgroundColor = 'white';
  dialog.style.border = '1px solid #ccc';
  dialog.style.padding = '20px';
  dialog.style.zIndex = '9999';
  dialog.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
  dialog.style.maxHeight = '80vh';
  dialog.style.overflowY = 'auto';

  // æ·»åŠ æ ‡é¢˜
  const title = document.createElement('h3');
  title.textContent = 'é€‰æ‹©è¦æ¢å¤çš„å¤‡ä»½';
  dialog.appendChild(title);

  // æ·»åŠ å¤‡ä»½åˆ—è¡¨
  const backupList = document.createElement('ul');
  backupKeys.forEach(key => {
    const listItem = document.createElement('li');
    const backupName = key.split('_').slice(-1).join('_'); // æå–å¤‡ä»½åç§°
    listItem.textContent = `${backupName}`;

    // ä¸ºæ¯ä¸ªå¤‡ä»½åˆ›å»ºæ¢å¤æŒ‰é’®
    const restoreButton = document.createElement('button');
    restoreButton.textContent = 'æ¢å¤è¯¥å¤‡ä»½';
    restoreButton.onclick = () => {
      // å¼¹å‡ºç¡®è®¤æ¡†ï¼Œç¡®è®¤æ˜¯å¦æ¢å¤
      const userConfirmed = confirm(`ç¡®å®šè¦æ¢å¤å¤‡ä»½ï¼š${backupName} å—ï¼Ÿ`);
      if (userConfirmed) {
        const backupData = localStorage.getItem(key);
        if (backupData) {
          const intervals = JSON.parse(backupData);
          localStorage.setItem('intervals', JSON.stringify(intervals));
          location.reload();  // åˆ·æ–°é¡µé¢ï¼Œæ¢å¤æ•°æ®
        } else {
          alert('å¤‡ä»½æ•°æ®æ— æ•ˆ');
        }
      }
    };

    // å°†æŒ‰é’®é™„åŠ åˆ°åˆ—è¡¨é¡¹
    listItem.appendChild(restoreButton);
    backupList.appendChild(listItem);
  });

  dialog.appendChild(backupList);

  // æ·»åŠ å…³é—­æŒ‰é’®
  const closeButton = document.createElement('button');
  closeButton.textContent = 'å–æ¶ˆ';
  closeButton.onclick = () => {
    document.body.removeChild(dialog);  // å…³é—­å¯¹è¯æ¡†
  };
  dialog.appendChild(closeButton);

  // æ˜¾ç¤ºå¯¹è¯æ¡†
  document.body.appendChild(dialog);
}

</script>
  <script>
// ruleTable.js

let ruleTable = JSON.parse(localStorage.getItem('ruleTable') || '[]');
let previousRuleTable = [];
let rowCount = Number(localStorage.getItem('ruleRowCount')) || 50;

function renderRuleTable() {
  const table = document.getElementById('rule-table');
  table.innerHTML = '';

  const headerRow = document.createElement('tr');
  ruleTable.forEach((col, colIdx) => {
    const th = document.createElement('th');
    const input = document.createElement('input');
    input.value = col.tag;
    input.oninput = (e) => {
      ruleTable[colIdx].tag = e.target.value;
      localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    };
    th.appendChild(input);
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  for (let row = 0; row < rowCount; row++) {
    const tr = document.createElement('tr');
    ruleTable.forEach((col, colIdx) => {
      const td = document.createElement('td');
      const input = document.createElement('input');
      input.value = col.keywords[row] || '';
      input.oninput = (e) => {
        ruleTable[colIdx].keywords[row] = e.target.value;
        localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
      };
      td.appendChild(input);
      tr.appendChild(td);
    });
    table.appendChild(tr);
  }
}

function addRuleColumn() {
  const newTag = `æ ‡ç­¾${ruleTable.length + 1}`;
  ruleTable.push({ tag: newTag, keywords: [] });
  localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
  renderRuleTable();
}

function addRuleRow() {
  rowCount += 1;
  localStorage.setItem('ruleRowCount', rowCount);
  renderRuleTable();
}

// å¤šè¯­è¨€æç¤ºå­—å…¸


function showRuleHelp() {
  alert(getI18n('ruleHelp'));
}


function exportRules() {
  const csv = ruleTable.map(col => col.tag).join(',') + '\n' +
    Array.from({ length: rowCount }, (_, i) =>
      ruleTable.map(col => col.keywords[i] || '').join(',')
    ).join('\n');

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ruleTable.csv';
  a.click();
  URL.revokeObjectURL(url);
}

function importRules(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const lines = reader.result.split(/\r?\n/);
    const tags = lines[0].split(',');
    const keywords = lines.slice(1).map(line => line.split(','));
    ruleTable = tags.map((tag, idx) => ({
      tag,
      keywords: keywords.map(row => row[idx] || '')
    }));
    rowCount = keywords.length;
    localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    localStorage.setItem('ruleRowCount', rowCount);
    renderRuleTable();
  };
  reader.readAsText(file);
}

function undoClearRules() {
  if (previousRuleTable.length > 0) {
    ruleTable = previousRuleTable;
    localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    renderRuleTable();
  }
}

function clearRuleTable() {
  previousRuleTable = JSON.parse(JSON.stringify(ruleTable));
  ruleTable = [];
  localStorage.setItem('ruleTable', '[]');
  renderRuleTable();
}

if (!ruleTable.length) {
  ruleTable = [
    { tag: 'æ ‡ç­¾1', keywords: [] },
    { tag: 'æ ‡ç­¾2', keywords: [] },
    { tag: 'æ ‡ç­¾3', keywords: [] },
    { tag: 'æ ‡ç­¾4', keywords: [] }
  ];
  localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
}

window.addEventListener('load', renderRuleTable);
window.addEventListener('load', () => {
  const buttonArea = document.createElement('div');
  buttonArea.innerHTML = `
    <button onclick="addRuleColumn()">â• å¢åŠ æ ‡ç­¾åˆ—</button>
    <button onclick="addRuleRow()">â• å¢åŠ å…³é”®å­—è¡Œ</button>
  `;
  document.getElementById('tab-rules').insertBefore(buttonArea, document.getElementById('rule-table'));
});
</script>
  <script>
// memoParser.js

function getI18n(key) {
  const lang = window.currentLang || 'zh';
  return (i18n[key] && i18n[key][lang]) || i18n[key]?.zh || '';
}

function parseMemo(index) {
  const intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
  const rules = JSON.parse(localStorage.getItem('ruleTable') || '[]');
  let item = intervals[index];

  if (!item) {
    alert(getI18n('parseFailed'));
    return;
  }

  const originalMemo = item.memo;
  item.memo = item.memo.trim();

  // æå–æœ«å°¾æ•°å­—ä½œä¸º setDuration
  const durationMatch = item.memo.match(/(\d+)\s*$/);
  if (durationMatch) {
    item.setDuration = Number(durationMatch[1]);
    item.memo = item.memo.replace(durationMatch[0], '').trim();
  } else if (item.duration < 60000 && !item.setDuration) {
    item.setDuration = 1;
  }

  const tags = new Set();
  let keywordRegion = item.memo;

  for (const col of rules) {
    let includeTag = false;
    let hasNegationHit = false;

    for (const keyword of col.keywords) {
      if (!keyword) break; // ç©ºç™½è¡Œä¸­æ–­è¯¥åˆ—å¤„ç†

      const isNegation = keyword.startsWith('~');
      const isForceDelete = keyword.includes('!');
      const cleaned = keyword.replace(/[~!]/g, '');

      // æ„Ÿå¹å·å…³é”®è¯å¤„ç†ï¼šåœ¨æœ«å°¾åç¼€ä¸­åˆ é™¤åŒ¹é…é¡¹
      if (isForceDelete) {
        const suffixMatch = keywordRegion.match(/([a-zA-Z0-9]+)$/);
        if (suffixMatch) {
          const suffix = suffixMatch[1];
          if (suffix.includes(cleaned)) {
            const newSuffix = suffix.replace(new RegExp(cleaned, 'g'), '');
            keywordRegion = keywordRegion.slice(0, -suffix.length) + newSuffix;
            includeTag = true;  // æ ‡è®°éœ€è¦æ·»åŠ æ ‡ç­¾
          }
        }
      }

      // å¦å®šå…³é”®è¯ï¼šåªåˆ¤æ–­ï¼Œä¸åˆ é™¤
      if (isNegation && keywordRegion.includes(cleaned)) {
        hasNegationHit = true;
      }

      // æ™®é€šå…³é”®è¯ï¼šåŒ¹é…åˆ™æ ‡è®°éœ€è¦æ·»åŠ æ ‡ç­¾
      if (!isNegation && !isForceDelete && keywordRegion.includes(cleaned)) {
        includeTag = true;
      }
    }

    if (includeTag && !hasNegationHit) {
      tags.add(col.tag);
    }
  }

  item.memo = keywordRegion.trim().replace(/\s+/g, ' ');
  item.tag = Array.from(tags).map(t => '#' + t).join(' ');
  item.parsed = true;
  item.originalMemo = originalMemo;

  intervals[index] = item;
  localStorage.setItem('intervals', JSON.stringify(intervals));
  location.reload();
}

function undoParse(index) {
  const intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
  const item = intervals[index];
  if (!item || !item.parsed) {
    alert(getI18n('undoFailed'));
    return;
  }

  item.memo = item.originalMemo;
  item.tag = '';
  item.setDuration = '';
  item.parsed = false;

  intervals[index] = item;
  localStorage.setItem('intervals', JSON.stringify(intervals));
  location.reload();
}

</script>
  <script>
// exportTomato.js

function exportTomatoPotato() {
  const raw = JSON.parse(localStorage.getItem('intervals') || '[]');
  if (!raw.length) {
    alert('æ²¡æœ‰è®°å½•å¯å¯¼å‡º');
    return;
  }

  // æ·±æ‹·è´é˜²æ­¢ä¿®æ”¹åŸå§‹æ•°æ®
  const intervals = JSON.parse(JSON.stringify(raw));

  // é¢„å¤„ç†ï¼šå››èˆäº”å…¥æ¯æ¡ interval çš„å®é™…æ—¶é•¿ï¼ˆå•ä½ï¼šåˆ†é’Ÿï¼‰
  intervals.forEach(item => {
    item.actualMin = Math.round(item.duration / 60000);
    if (!item.setDuration && item.actualMin < 1) {
      item.setDuration = 1;
    }
  });

  // åˆ†é…æ—¶é—´ï¼šæŒ‰ setDuration ä¼˜å…ˆçº§è°ƒæ•´
  for (let i = 0; i < intervals.length; i++) {
    const cur = intervals[i];
    if (cur.setDuration) {
      const t = cur.setDuration;
      const d = cur.actualMin;
      if (t < d) {
        // å‘åè¡¥ç»™å¤šä½™çš„æ—¶é—´
        let extra = d - t;
        for (let j = i + 1; j < intervals.length && extra > 0; j++) {
          if (!intervals[j].setDuration) {
            intervals[j].actualMin += extra;
            break;
          }
        }
        cur.actualMin = t;
      } else if (t > d) {
        // å‘å‰å€Ÿç”¨æ—¶é—´
        let need = t - d;
        for (let j = i - 1; j >= 0 && need > 0; j--) {
          if (!intervals[j].setDuration && intervals[j].actualMin > need) {
            intervals[j].actualMin -= need;
            break;
          }
        }
        cur.actualMin = t;
      }
    }
  }

  const output = intervals.map(item => {
    const tag = item.tag || '';
    const memo = item.memo || '';
    const min = item.actualMin;
    return `${tag} ${memo} ${min}min`.trim();
  }).join(' + ');

  document.getElementById('tomato-output').textContent = output;
  navigator.clipboard.writeText(output);
  alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
}

</script>

<style>
  .main-container {
    margin-left: auto;
    margin-right: auto;
    max-width: 1000px;
  }
</style>


<style>
  .main-container {
    margin-left: auto;
    margin-right: auto;
    max-width: 1000px;
  }
  .main-input {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    margin-top: 0.5em;
  }
  .main-button {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    margin-top: 8px;
    box-sizing: border-box;
  }
</style>


<style>
  body.dark-mode {
    background-color: #121212;
    color: #e0e0e0;
  }
  body.dark-mode input, 
  body.dark-mode button, 
  body.dark-mode textarea {
    background-color: #1e1e1e;
    color: #ffffff;
    border-color: #444;
  }
  body.dark-mode .tab-button {
    background-color: #1e1e1e;
    color: #ffffff;
    border: 1px solid #444;
  }
</style>

<script>
  function toggleDarkMode() {
    document.body.classList.toggle("dark-mode");
    localStorage.setItem("dark-mode", document.body.classList.contains("dark-mode"));
  }
  window.addEventListener("DOMContentLoaded", () => {
    if (localStorage.getItem("dark-mode") === "true") {
      document.body.classList.add("dark-mode");
    }
  });
</script>


<style>
  html {
    font-size: 18px;
  }
  button {
    font-size: 1rem !important;
  }
  input {
    font-size: 1rem !important;
  }
  #lang-toggle,
  #dark-toggle {
    font-size: 0.9rem;
    padding: 4px 8px;
  }
  .interval-record input {
    font-size: 1rem;
  }
  .interval-record {
    margin-bottom: 2em;
  }
</style>

</head>
<body>
  <h1 class="main-container" style="padding-left: 0px; padding-right: 0px;" data-zh="â±ï¸ æœ¬åœ°ç½‘é¡µç§’è¡¨" data-mix="â±ï¸ æœ¬åœ°ç½‘é¡µç§’è¡¨" data-en="â±ï¸ Local Stopwatch">â±ï¸ æœ¬åœ°ç½‘é¡µç§’è¡¨</h1>
  
  <div class="tabs main-container" style="padding-left: 0px; padding-right: 0px;">  
    <button class="tab-button" onclick="showTab('tab-timer')" data-zh="è®¡æ—¶å™¨" data-mix="è®¡æ—¶å™¨" data-en="Timer">è®¡æ—¶å™¨</button>
    <button class="tab-button" onclick="showTab('tab-rules')" data-zh="å®šä¹‰å¤‡æ³¨è§£æè§„åˆ™" data-mix="å®šä¹‰Memoè§£æè§„åˆ™" data-en="Memo Parsing Rules">å®šä¹‰å¤‡æ³¨è§£æè§„åˆ™</button>
    <button class="tab-button" onclick="showTab('tab-export')" data-zh="ç•ªèŒ„åœŸè±†æ ¼å¼å¯¼å‡º" data-mix="ç•ªèŒ„åœŸè±†æ ¼å¼å¯¼å‡º" data-en="Tomato Export">ç•ªèŒ„åœŸè±†æ ¼å¼å¯¼å‡º</button>
    <button class="tab-button" onclick="showTab('tab-log')" data-zh="è¿è¡Œæ—¥å¿—å’Œå¤‡ä»½" data-mix="è¿è¡Œæ—¥å¿—å’Œå¤‡ä»½" data-en="Log & Backups">è¿è¡Œæ—¥å¿—å’Œå¤‡ä»½</button>

    <button class="tab-button" onclick="toggleDarkMode()" id="dark-toggle">ğŸŒ“ æ·±è‰²æ¨¡å¼</button>
  <button class="tab-button" id="lang-toggle" onclick="toggleLang()">English</button>
</div>

  <div id="tab-timer" class="tab-content">
    <section id="display-section" class="main-container">
      <h2 data-zh="å½“å‰è®°å½•æ®µæŒç»­æ—¶é—´" data-mix="å½“å‰IntervalæŒç»­æ—¶é—´" data-en="Current Interval Duration">å½“å‰è®°å½•æ®µæŒç»­æ—¶é—´</h2>
      <div id="current-duration" class="big-time">00:00:00.00</div>
      <div class="sub-time" id="current-date"></div>

      <h2 data-zh="å½“å‰ç»å¯¹æ—¶é—´" data-mix="å½“å‰ç»å¯¹æ—¶é—´" data-en="Current Absolute Time">å½“å‰ç»å¯¹æ—¶é—´</h2>
      <div id="absolute-time" class="big-time">--:--:--</div>
      <div class="sub-time" id="absolute-date"></div>

      <section class="main-container" style="margin-top: 12px;">
<button onclick="toggleInitialTime()" id="toggle-initial-time-btn">æ˜¾ç¤ºç¬¬ä¸€ä¸ªå¼€å§‹æ—¶é—´</button>
</section>
<section class="main-container">
<div id="initial-time-section" style="display:none;">
  <h2 data-zh="ç¬¬ä¸€ä¸ªè®°å½•æ®µå¼€å§‹çš„æ—¶é—´" data-mix="ç¬¬ä¸€ä¸ªIntervalå¼€å§‹çš„æ—¶é—´" data-en="First Interval Start Time">ç¬¬ä¸€ä¸ªè®°å½•æ®µå¼€å§‹çš„æ—¶é—´</h2>
  <div id="initial-time" class="big-time">--:--:--</div>
  <div class="sub-time" id="initial-date"></div>
</div>
    </section>

    <section id="upper-controls" class="main-container" style="display: flex; flex-direction: column; align-items: flex-start; gap: 10px; margin-top: 30px; padding: 0 20px; max-width: 1000px;">
  <div style="display: flex; flex-wrap: wrap; gap: 8px;">
    <button onclick="confirmExportAndClear()" data-zh="å¯¼å‡ºå¹¶æ¸…ç©ºè®°å½•" data-mix="å¯¼å‡ºå¹¶æ¸…ç©ºè®°å½•" data-en="Export & Clear">å¯¼å‡ºå¹¶æ¸…ç©ºè®°å½•</button>
    <button onclick="exportIntervalsToCSV()" data-zh="å¯¼å‡ºCSV" data-mix="å¯¼å‡ºCSV" data-en="Export CSV">å¯¼å‡ºCSV</button>
    <button onclick="triggerManualBackup()" data-zh="æ‰‹åŠ¨å¤‡ä»½" data-mix="æ‰‹åŠ¨å¤‡ä»½" data-en="Manual Backup">æ‰‹åŠ¨å¤‡ä»½</button>
    <button onclick="restoreLatestBackup()" data-zh="æ¢å¤å†å²å¤‡ä»½" data-mix="æ¢å¤å†å²å¤‡ä»½" data-en="Restore Backup">æ¢å¤å†å²å¤‡ä»½</button>
  </div>
  <input id="memo-input" placeholder="å½“å‰è®°å½•æ®µçš„å¤‡æ³¨..." maxlength="1000" class="main-input">
<button onclick="rememberInterval()" class="main-button" data-zh="è®°ä¸‹" data-mix="è®°ä¸‹" data-en="Remember">è®°ä¸‹</button>
</div>
<section id="intervals-section" class="main-container">
      <h2 data-zh="å†å²è®°å½•" data-mix="å†å²è®°å½•" data-en="History">å†å²è®°å½•</h2>
      <div id="intervals-container"></div>
    </section>
  </div>

  <div id="tab-rules" class="tab-content" style="display:none">
    <h2 data-zh="å¤‡æ³¨è§£æè§„åˆ™" data-mix="Memoè§£æè§„åˆ™" data-en="Memo Parsing Rules">å¤‡æ³¨è§£æè§„åˆ™</h2>
    <button onclick="showRuleHelp()" data-zh=" ä½¿ç”¨æ–¹æ³•" data-mix=" ä½¿ç”¨æ–¹æ³•" data-en=" Help"> ä½¿ç”¨æ–¹æ³•</button>
    <button onclick="exportRules()" data-zh=" å¯¼å‡ºè§„åˆ™" data-mix=" å¯¼å‡ºè§„åˆ™" data-en=" Export Rules"> å¯¼å‡ºè§„åˆ™</button>
    <input type="file" id="import-rule-file" accept=".csv" onchange="importRules(event)">
    <button onclick="undoClearRules()" data-zh="â†©ï¸ æ’¤é”€æ¸…ç©ºè§„åˆ™" data-mix="â†©ï¸ æ’¤é”€æ¸…ç©ºè§„åˆ™" data-en="â†©ï¸ Undo Clear">â†©ï¸ æ’¤é”€æ¸…ç©ºè§„åˆ™</button>
    <table id="rule-table"></table>
  </div>

  <div id="tab-export" class="tab-content" style="display:none">
    <h2 data-zh=" å¯¼å‡ºç•ªèŒ„åœŸè±†æ ¼å¼" data-mix=" å¯¼å‡ºç•ªèŒ„åœŸè±†æ ¼å¼" data-en=" Tomato Export"> å¯¼å‡ºç•ªèŒ„åœŸè±†æ ¼å¼</h2>
    <button onclick="exportTomatoPotato()" data-zh=" ç”Ÿæˆå¹¶å¤åˆ¶" data-mix=" ç”Ÿæˆå¹¶å¤åˆ¶" data-en=" Generate & Copy"> ç”Ÿæˆå¹¶å¤åˆ¶</button>
    <div id="tomato-output"></div>
  </div>

  <div id="tab-log" class="tab-content" style="display:none">
    <h2 data-zh="ï¸ è¿è¡Œæ—¥å¿—" data-mix="ï¸ è¿è¡Œæ—¥å¿—" data-en="ï¸ Log">ï¸ è¿è¡Œæ—¥å¿—</h2>
    <button onclick="refreshLog()" data-zh=" åˆ·æ–°æ—¥å¿—" data-mix=" åˆ·æ–°æ—¥å¿—" data-en=" Refresh Log"> åˆ·æ–°æ—¥å¿—</button>
    <button onclick="copyLog()" data-zh=" å¤åˆ¶æ—¥å¿—" data-mix=" å¤åˆ¶æ—¥å¿—" data-en=" Copy Log"> å¤åˆ¶æ—¥å¿—</button>
    <button onclick="clearLog()" data-zh="ï¸ æ¸…ç©ºæ—¥å¿—" data-mix="ï¸ æ¸…ç©ºæ—¥å¿—" data-en="ï¸ Clear Log">ï¸ æ¸…ç©ºæ—¥å¿—</button>
    <pre id="log-content"></pre>
    <h3 data-zh=" å¯ç”¨å¤‡ä»½åˆ—è¡¨" data-mix=" å¯ç”¨å¤‡ä»½åˆ—è¡¨" data-en=" Available Backups"> å¯ç”¨å¤‡ä»½åˆ—è¡¨</h3>
    <div id="backup-list"></div>
    
  </div>

  <div id="confirm-clear-dialog" style="display:none; padding:1em; background:#fff; border:1px solid #ccc; position:fixed; top:30%; left:30%; z-index:9999; box-shadow:0 0 10px rgba(0,0,0,0.2);">
    <p data-zh="âš ï¸ æ˜¯å¦è¦å¯¼å‡ºæ‰€æœ‰è®°å½•å¹¶æ¸…ç©ºï¼Ÿæ“ä½œä¸å¯æ’¤é”€ã€‚" data-mix="âš ï¸ æ˜¯å¦è¦å¯¼å‡ºæ‰€æœ‰è®°å½•å¹¶æ¸…ç©ºï¼Ÿæ“ä½œä¸å¯æ’¤é”€ã€‚" data-en="âš ï¸ Export and clear all records? This cannot be undone.">âš ï¸ æ˜¯å¦è¦å¯¼å‡ºæ‰€æœ‰è®°å½•å¹¶æ¸…ç©ºï¼Ÿæ“ä½œä¸å¯æ’¤é”€ã€‚</p>
    <button onclick="exportThenClear()" data-zh="âœ… ç¡®è®¤å¯¼å‡ºå¹¶æ¸…ç©º" data-mix="âœ… ç¡®è®¤å¯¼å‡ºå¹¶æ¸…ç©º" data-en="âœ… Confirm Export & Clear">âœ… ç¡®è®¤å¯¼å‡ºå¹¶æ¸…ç©º</button>
    <button onclick="document.getElementById('confirm-clear-dialog').style.display='none'" data-zh="âŒ å–æ¶ˆ" data-mix="âŒ å–æ¶ˆ" data-en="âŒ Cancel">âŒ å–æ¶ˆ</button>
  <footer>
    <hr>
    <small>å‚è€ƒäº†åŸç½‘é¡µ https://stopwatch.online-timers.com/stopwatch-with-time-intervals çš„åŠŸèƒ½ï¼Œç”± ChatGPT é‡æ–°ç¼–å†™ä»£ç å¹¶æ·»åŠ äº†ä¸ªæ€§åŒ–ä¿®æ”¹ã€‚<br>é¡¹ç›®åœ°å€ï¼š<a href="https://github.com/SamZebrado/LocalStopWatch" target="_blank">https://github.com/SamZebrado/LocalStopWatch</a></small>
  </footer>

  <script>
    function showTab(id) {
      document.querySelectorAll('.tab-content').forEach(div => div.style.display = 'none');
      document.getElementById(id).style.display = 'block';
    }
    function confirmExportAndClear() {
      document.getElementById('confirm-clear-dialog').style.display = 'block';
    }
    function exportThenClear() {
      exportIntervalsToCSV();
      intervals = [];
      localStorage.setItem('intervals', JSON.stringify(intervals));
      document.getElementById('intervals-container').innerHTML = '';
      document.getElementById('confirm-clear-dialog').style.display = 'none';
    }
  // åˆå§‹åŒ–è¯­è¨€çŠ¶æ€ï¼ˆä¼˜å…ˆä» localStorage è¯»å–ï¼‰
  let currentLang = localStorage.getItem('lang') || 'mix';
  const langCycle = ['zh', 'mix', 'en'];

  function updateLangUI() {
    document.querySelectorAll('[data-zh]').forEach(el => {
      const val = el.getAttribute('data-' + currentLang);
      if (val) el.textContent = val;
    });

    // æŒ‰é’®æ˜¾ç¤ºä¸‹ä¸€ä¸ªè¯­è¨€åç§°
    const idx = langCycle.indexOf(currentLang);
    const nextLang = langCycle[(idx + 1) % langCycle.length];
    
    
    const labelMap = {
      zh: ' ä¸­æ–‡',//è¿™æ ·èƒ½ä¸â€œä¸‹ä¸€ä¸ªâ€è¯­è¨€ä¸€è‡´
      mix: ' ä¸­æ–‡+English',
      en: ' English'
    };
    document.getElementById('lang-toggle').textContent = labelMap[nextLang];
  }

  function toggleLang() {
    const idx = langCycle.indexOf(currentLang);
    currentLang = langCycle[(idx + 1) % langCycle.length];
    localStorage.setItem('lang', currentLang);
    updateLangUI();
  }

  // é¡µé¢åŠ è½½ååº”ç”¨è¯­è¨€
  document.addEventListener('DOMContentLoaded', updateLangUI);

  </script>
</body>
</html>
