<!-- stopwatch.html ä¸»é¡µé¢ -->
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>æœ¬åœ°ç½‘é¡µç§’è¡¨</title>
  <link rel="stylesheet" href="style.css">
  <script>
  // timer.js

let t_Initial = Number(localStorage.getItem('t_Initial')) || Date.now();
let t_Last = Number(localStorage.getItem('t_Last')) || t_Initial;
let intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
let logs = JSON.parse(localStorage.getItem('logs') || '[]');

function pad(n, z = 2) { return ('00' + n).slice(-z); }

function formatTime(ms) {
  let totalSeconds = Math.floor(ms / 1000);
  let hours = Math.floor(totalSeconds / 3600);
  let minutes = Math.floor((totalSeconds % 3600) / 60);
  let seconds = totalSeconds % 60;
  let fraction = Math.floor((ms % 1000));
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${String(fraction).padStart(3, '0')}`;
}

function exportIntervalsToCSV() {
  if (!intervals.length) {
    alert('æ²¡æœ‰è®°å½•å¯å¯¼å‡º');
    return;
  }

  const rows = [
    ['æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰', 'æ ¼å¼åŒ–æ—¶é—´', 'å¤‡æ³¨', 'æ ‡ç­¾', 'ç»“æŸæ—¶é—´']
  ];

  intervals.forEach(item => {
    const mins = item.durationMs ? (item.durationMs / 60000).toFixed(2) : '';
    rows.push([
      mins,
      item.duration || '',
      item.memo || '',
      item.tag || '',
      new Date(item.endTime).toLocaleString()
    ]);
  });

  const csv = rows.map(row => row.map(val => `"${val}"`).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'intervals.csv';
  a.click();
  URL.revokeObjectURL(url);
}

function updateDisplay() {
  const now = Date.now();
  const elapsed = now - t_Last;

  document.getElementById('current-duration').textContent = formatTime(elapsed);
  document.getElementById('absolute-time').textContent = new Date(now).toLocaleTimeString();
  document.getElementById('absolute-date').textContent = new Date(now).toLocaleDateString();
  document.getElementById('initial-time').textContent = new Date(t_Initial).toLocaleTimeString();
  document.getElementById('initial-date').textContent = new Date(t_Initial).toLocaleDateString();

  requestAnimationFrame(updateDisplay);
}

function renderIntervals() {
  const container = document.getElementById('intervals-container');
  container.innerHTML = '';

  intervals.slice().reverse().forEach((item, index) => {
    const trueIndex = intervals.length - 1 - index;
    const div = document.createElement('div');
    div.className = 'interval-record';
    const mins = item.durationMs ? (item.durationMs / 60000).toFixed(2) : '--';
    div.innerHTML = `
      <div><strong class="duration">${mins} åˆ†é’Ÿ</strong></div>
      <div>Tag: <input value="${item.tag || ''}" oninput="updateTag(${trueIndex}, this.value)"></div>
      <div>Memo: <input value="${item.memo}" oninput="updateMemo(${trueIndex}, this.value)"></div>
      <div>æŒ‡å®šæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰: <input type="number" value="${item.setDuration || ''}" oninput="updateSetDuration(${trueIndex}, this.value)"></div>
      <div>ç»“æŸæ—¶é—´: ${new Date(item.endTime).toLocaleString()}</div>
      <button onclick="parseMemo(${trueIndex})">è§£æMemo</button>
      <button onclick="undoParse(${trueIndex})">æ’¤é”€</button>
    `;
    if (item.parsed) div.style.background = '#eee';
    container.appendChild(div);
  });
}

function rememberInterval() {
  const now = Date.now();
  const durationMs = now - t_Last;
  const memo = document.getElementById('memo-input').value.trim();

  const item = {
    memo,
    tag: '',
    duration: formatTime(durationMs),
    durationMs,
    endTime: now,
    setDuration: '',
    originalMemo: memo,
    parsed: false
  };

  intervals.push(item);
  localStorage.setItem('intervals', JSON.stringify(intervals));
  document.getElementById('memo-input').value = '';

  t_Last = now;
  localStorage.setItem('t_Last', t_Last);
  renderIntervals();
}

function updateTag(index, value) {
  intervals[index].tag = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function updateMemo(index, value) {
  intervals[index].memo = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function updateSetDuration(index, value) {
  intervals[index].setDuration = value;
  localStorage.setItem('intervals', JSON.stringify(intervals));
}

function resetTimer() {
  t_Initial = Date.now();
  t_Last = t_Initial;
  localStorage.setItem('t_Initial', t_Initial);
  localStorage.setItem('t_Last', t_Initial);
}

function updateLogDisplay() {
  const logText = logs.map(l => `ã€${l.type}ã€‘${l.time}`).join('\n---\n');
  document.getElementById('log-content').textContent = logText;
}

function refreshLog() {
  logs = logs.filter(l => l.type !== 'Interval');
  intervals.forEach(item => {
    logs.push({
      type: 'Interval',
      time: new Date(item.endTime).toLocaleString()
    });
  });
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
}

function clearLog() {
  logs = [];
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
}

function copyLog() {
  navigator.clipboard.writeText(document.getElementById('log-content').textContent);
}

window.onload = () => {
  updateDisplay();
  renderIntervals();
  logs.push({ type: 'åˆ·æ–°', time: new Date().toLocaleString() });
  localStorage.setItem('logs', JSON.stringify(logs));
  updateLogDisplay();
};

  </script>
  <script>
  // ruleTable.js

let ruleTable = JSON.parse(localStorage.getItem('ruleTable') || '[]');
let previousRuleTable = [];
let rowCount = Number(localStorage.getItem('ruleRowCount')) || 50;

function renderRuleTable() {
  const table = document.getElementById('rule-table');
  table.innerHTML = '';

  const headerRow = document.createElement('tr');
  ruleTable.forEach((col, colIdx) => {
    const th = document.createElement('th');
    const input = document.createElement('input');
    input.value = col.tag;
    input.oninput = (e) => {
      ruleTable[colIdx].tag = e.target.value;
      localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    };
    th.appendChild(input);
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  for (let row = 0; row < rowCount; row++) {
    const tr = document.createElement('tr');
    ruleTable.forEach((col, colIdx) => {
      const td = document.createElement('td');
      const input = document.createElement('input');
      input.value = col.keywords[row] || '';
      input.oninput = (e) => {
        ruleTable[colIdx].keywords[row] = e.target.value;
        localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
      };
      td.appendChild(input);
      tr.appendChild(td);
    });
    table.appendChild(tr);
  }
}

function addRuleColumn() {
  const newTag = `æ ‡ç­¾${ruleTable.length + 1}`;
  ruleTable.push({ tag: newTag, keywords: [] });
  localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
  renderRuleTable();
}

function addRuleRow() {
  rowCount += 1;
  localStorage.setItem('ruleRowCount', rowCount);
  renderRuleTable();
}

function showRuleHelp() {
  alert(`è§„åˆ™è¯´æ˜ï¼š\n\n1. ç¬¬ä¸€è¡Œæ˜¯æ ‡ç­¾åï¼ˆTagï¼‰ï¼Œå¯ç‚¹å‡»ç¼–è¾‘ï¼›\n2. æ¯åˆ—ä¸ºä¸€ä¸ªæ ‡ç­¾ï¼Œä¸‹é¢å¡«å†™è¯¥æ ‡ç­¾çš„å…³é”®å­—ï¼›\n3. ç²¾ç¡®åŒ¹é…ï¼Œå¤§å°å†™æ•æ„Ÿï¼›\n4. è‹¥å…³é”®å­—å‰åŠ  ~ è¡¨ç¤ºâ€œå¤‡æ³¨ä¸­ä¸åŒ…å«è¯¥è¯â€æ—¶åŒ¹é…ã€‚`);
}

function exportRules() {
  const csv = ruleTable.map(col => col.tag).join(',') + '\n' +
    Array.from({ length: rowCount }, (_, i) =>
      ruleTable.map(col => col.keywords[i] || '').join(',')
    ).join('\n');

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ruleTable.csv';
  a.click();
  URL.revokeObjectURL(url);
}

function importRules(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const lines = reader.result.split(/\r?\n/);
    const tags = lines[0].split(',');
    const keywords = lines.slice(1).map(line => line.split(','));
    ruleTable = tags.map((tag, idx) => ({
      tag,
      keywords: keywords.map(row => row[idx] || '')
    }));
    rowCount = keywords.length;
    localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    localStorage.setItem('ruleRowCount', rowCount);
    renderRuleTable();
  };
  reader.readAsText(file);
}

function undoClearRules() {
  if (previousRuleTable.length > 0) {
    ruleTable = previousRuleTable;
    localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
    renderRuleTable();
  }
}

function clearRuleTable() {
  previousRuleTable = JSON.parse(JSON.stringify(ruleTable));
  ruleTable = [];
  localStorage.setItem('ruleTable', '[]');
  renderRuleTable();
}

if (!ruleTable.length) {
  ruleTable = [
    { tag: 'æ ‡ç­¾1', keywords: [] },
    { tag: 'æ ‡ç­¾2', keywords: [] },
    { tag: 'æ ‡ç­¾3', keywords: [] },
    { tag: 'æ ‡ç­¾4', keywords: [] }
  ];
  localStorage.setItem('ruleTable', JSON.stringify(ruleTable));
}

window.addEventListener('load', renderRuleTable);
window.addEventListener('load', () => {
  const buttonArea = document.createElement('div');
  buttonArea.innerHTML = `
    <button onclick="addRuleColumn()">â• å¢åŠ æ ‡ç­¾åˆ—</button>
    <button onclick="addRuleRow()">â• å¢åŠ å…³é”®å­—è¡Œ</button>
  `;
  document.getElementById('tab-rules').insertBefore(buttonArea, document.getElementById('rule-table'));
});
  </script>
  <script>
  // memoParser.js

function parseMemo(index) {
  const intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
  const rules = JSON.parse(localStorage.getItem('ruleTable') || '[]');
  let item = intervals[index];
  if (!item) return;

  item.memo = item.memo.trim();
  const original = item.memo;

  // æå–ç»“å°¾æ•°å­—ä½œä¸º setDuration
  const durationMatch = item.memo.match(/(\d+)\s*$/);
  if (durationMatch) {
    item.setDuration = Number(durationMatch[1]);
    item.memo = item.memo.replace(/(\d+)\s*$/, '').trim();
  } else if (item.duration < 60000 && !item.setDuration) {
    item.setDuration = 1;
  }

  let keywordRegion = item.memo;
  const tags = new Set();

  // å·¦åˆ°å³æ‰«æï¼ŒåŒ¹é…æˆåŠŸå³å‰”é™¤
  let pointer = 0;
  while (pointer < keywordRegion.length) {
    let matched = false;
    rules.forEach(col => {
      col.keywords.forEach(keyword => {
        if (!keyword || keyword.startsWith('~')) return;
        if (keywordRegion.startsWith(keyword, pointer)) {
          tags.add(col.tag);
          keywordRegion = keywordRegion.slice(0, pointer) + keywordRegion.slice(pointer + keyword.length);
          matched = true;
        }
      });
    });
    if (!matched) {
      pointer++;
    }
  }

  item.memo = keywordRegion.trim().replace(/\s+/g, ' ');
  item.tag = Array.from(tags).map(t => '#' + t).join(' ');
  item.parsed = true;
  item.originalMemo = original;

  intervals[index] = item;
  localStorage.setItem('intervals', JSON.stringify(intervals));
  location.reload();
}

function undoParse(index) {
  const intervals = JSON.parse(localStorage.getItem('intervals') || '[]');
  const item = intervals[index];
  if (!item || !item.parsed) return;

  item.memo = item.originalMemo;
  item.tag = '';
  item.setDuration = '';
  item.parsed = false;

  // ä¿ç•™åŸå§‹æ¯«ç§’ durationï¼ˆä»å­—ç¬¦ä¸²è¿˜åŸå¤±è´¥æ—¶ä¸åŠ¨ï¼‰
  if (typeof item.rawDuration === 'number') {
    item.duration = item.rawDuration;
  }

  intervals[index] = item;
  localStorage.setItem('intervals', JSON.stringify(intervals));
  location.reload();
}
  </script>
  <script>
  // exportTomato.js

function exportTomatoPotato() {
  const raw = JSON.parse(localStorage.getItem('intervals') || '[]');
  if (!raw.length) {
    alert('æ²¡æœ‰è®°å½•å¯å¯¼å‡º');
    return;
  }

  // æ·±æ‹·è´é˜²æ­¢ä¿®æ”¹åŸå§‹æ•°æ®
  const intervals = JSON.parse(JSON.stringify(raw));

  // é¢„å¤„ç†ï¼šå››èˆäº”å…¥æ¯æ¡ interval çš„å®é™…æ—¶é•¿ï¼ˆå•ä½ï¼šåˆ†é’Ÿï¼‰
  intervals.forEach(item => {
    item.actualMin = Math.round(item.duration / 60000);
    if (!item.setDuration && item.actualMin < 1) {
      item.setDuration = 1;
    }
  });

  // åˆ†é…æ—¶é—´ï¼šæŒ‰ setDuration ä¼˜å…ˆçº§è°ƒæ•´
  for (let i = 0; i < intervals.length; i++) {
    const cur = intervals[i];
    if (cur.setDuration) {
      const t = cur.setDuration;
      const d = cur.actualMin;
      if (t < d) {
        // å‘åè¡¥ç»™å¤šä½™çš„æ—¶é—´
        let extra = d - t;
        for (let j = i + 1; j < intervals.length && extra > 0; j++) {
          if (!intervals[j].setDuration) {
            intervals[j].actualMin += extra;
            break;
          }
        }
        cur.actualMin = t;
      } else if (t > d) {
        // å‘å‰å€Ÿç”¨æ—¶é—´
        let need = t - d;
        for (let j = i - 1; j >= 0 && need > 0; j--) {
          if (!intervals[j].setDuration && intervals[j].actualMin > need) {
            intervals[j].actualMin -= need;
            break;
          }
        }
        cur.actualMin = t;
      }
    }
  }

  const output = intervals.map(item => {
    const tag = item.tag || '';
    const memo = item.memo || '';
    const min = item.actualMin;
    return `${tag} ${memo} ${min}min`.trim();
  }).join(' + ');

  document.getElementById('tomato-output').textContent = output;
  navigator.clipboard.writeText(output);
  alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
}
</script>
  <style>
    #lang-toggle {
      position: absolute;
      top: 1rem;
      right: 1rem;
    }
  </style>
</head>
<body>
  <button id="lang-toggle" onclick="toggleLang()">ğŸŒ English</button>
  <h1 data-zh="â±ï¸ æœ¬åœ°ç½‘é¡µç§’è¡¨" data-en="â±ï¸ Local Stopwatch">â±ï¸ æœ¬åœ°ç½‘é¡µç§’è¡¨</h1>
  <div class="tabs">
    <button class="tab-button" onclick="showTab('tab-timer')" data-zh="è®¡æ—¶å™¨" data-en="Timer">è®¡æ—¶å™¨</button>
    <button class="tab-button" onclick="showTab('tab-rules')" data-zh="å®šä¹‰Memoè§£æè§„åˆ™" data-en="Memo Parsing Rules">å®šä¹‰Memoè§£æè§„åˆ™</button>
    <button class="tab-button" onclick="showTab('tab-export')" data-zh="ç•ªèŒ„åœŸè±†æ ¼å¼å¯¼å‡º" data-en="Tomato Export">ç•ªèŒ„åœŸè±†æ ¼å¼å¯¼å‡º</button>
    <button class="tab-button" onclick="showTab('tab-log')" data-zh="è¿è¡Œæ—¥å¿—" data-en="Log">è¿è¡Œæ—¥å¿—</button>
  </div>

  <div id="tab-timer" class="tab-content">
    <section id="display-section">
      <h2 data-zh="å½“å‰IntervalæŒç»­æ—¶é—´" data-en="Current Interval Duration">å½“å‰IntervalæŒç»­æ—¶é—´</h2>
      <div id="current-duration" class="big-time">00:00:00.00</div>
      <div class="sub-time" id="current-date"></div>

      <h2 data-zh="å½“å‰ç»å¯¹æ—¶é—´" data-en="Current Absolute Time">å½“å‰ç»å¯¹æ—¶é—´</h2>
      <div id="absolute-time" class="big-time">--:--:--</div>
      <div class="sub-time" id="absolute-date"></div>

      <h2 data-zh="ç¬¬ä¸€ä¸ªIntervalå¼€å§‹çš„æ—¶é—´" data-en="First Interval Start Time">ç¬¬ä¸€ä¸ªIntervalå¼€å§‹çš„æ—¶é—´</h2>
      <div id="initial-time" class="big-time">--:--:--</div>
      <div class="sub-time" id="initial-date"></div>
    </section>

    <section id="control-section">
      <input id="memo-input" placeholder="å½“å‰ interval çš„å¤‡æ³¨..." maxlength="1000">
      <button onclick="rememberInterval()" data-zh="ğŸ“Œ è®°ä¸‹" data-en="ğŸ“Œ Remember">ğŸ“Œ è®°ä¸‹</button>
      <button onclick="confirmExportAndClear()" data-zh="ğŸ“ å¯¼å‡ºå¹¶æ¸…ç©ºè®°å½•" data-en="ğŸ“ Export & Clear">ğŸ“ å¯¼å‡ºå¹¶æ¸…ç©ºè®°å½•</button>
      <button onclick="exportIntervalsToCSV()" data-zh="ğŸ“¤ å¯¼å‡ºCSV" data-en="ğŸ“¤ Export CSV">ğŸ“¤ å¯¼å‡ºCSV</button>
    </section>

    <section id="intervals-section">
      <h2 data-zh="å†å²è®°å½•" data-en="History">å†å²è®°å½•</h2>
      <div id="intervals-container"></div>
    </section>
  </div>

  <div id="tab-rules" class="tab-content" style="display:none">
    <h2 data-zh="Memoè§£æè§„åˆ™" data-en="Memo Parsing Rules">Memoè§£æè§„åˆ™</h2>
    <button onclick="showRuleHelp()" data-zh="ğŸ“– ä½¿ç”¨æ–¹æ³•" data-en="ğŸ“– Help">ğŸ“– ä½¿ç”¨æ–¹æ³•</button>
    <button onclick="exportRules()" data-zh="ğŸ“¤ å¯¼å‡ºè§„åˆ™" data-en="ğŸ“¤ Export Rules">ğŸ“¤ å¯¼å‡ºè§„åˆ™</button>
    <input type="file" id="import-rule-file" accept=".csv" onchange="importRules(event)">
    <button onclick="undoClearRules()" data-zh="â†©ï¸ æ’¤é”€æ¸…ç©ºè§„åˆ™" data-en="â†©ï¸ Undo Clear">â†©ï¸ æ’¤é”€æ¸…ç©ºè§„åˆ™</button>
    <table id="rule-table"></table>
  </div>

  <div id="tab-export" class="tab-content" style="display:none">
    <h2 data-zh="ğŸ… å¯¼å‡ºç•ªèŒ„åœŸè±†æ ¼å¼" data-en="ğŸ… Tomato Export">ğŸ… å¯¼å‡ºç•ªèŒ„åœŸè±†æ ¼å¼</h2>
    <button onclick="exportTomatoPotato()" data-zh="ğŸ“‹ ç”Ÿæˆå¹¶å¤åˆ¶" data-en="ğŸ“‹ Generate & Copy">ğŸ“‹ ç”Ÿæˆå¹¶å¤åˆ¶</button>
    <div id="tomato-output"></div>
  </div>

  <div id="tab-log" class="tab-content" style="display:none">
    <h2 data-zh="ğŸ› ï¸ è¿è¡Œæ—¥å¿—" data-en="ğŸ› ï¸ Log">ğŸ› ï¸ è¿è¡Œæ—¥å¿—</h2>
    <button onclick="refreshLog()" data-zh="ğŸ”„ åˆ·æ–°æ—¥å¿—" data-en="ğŸ”„ Refresh Log">ğŸ”„ åˆ·æ–°æ—¥å¿—</button>
    <button onclick="copyLog()" data-zh="ğŸ“‹ å¤åˆ¶æ—¥å¿—" data-en="ğŸ“‹ Copy Log">ğŸ“‹ å¤åˆ¶æ—¥å¿—</button>
    <button onclick="clearLog()" data-zh="ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—" data-en="ğŸ—‘ï¸ Clear Log">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
    <pre id="log-content"></pre>
  </div>

  <div id="confirm-clear-dialog" style="display:none; padding:1em; background:#fff; border:1px solid #ccc; position:fixed; top:30%; left:30%; z-index:9999; box-shadow:0 0 10px rgba(0,0,0,0.2);">
    <p data-zh="âš ï¸ æ˜¯å¦è¦å¯¼å‡ºæ‰€æœ‰è®°å½•å¹¶æ¸…ç©ºï¼Ÿæ“ä½œä¸å¯æ’¤é”€ã€‚" data-en="âš ï¸ Export and clear all records? This cannot be undone.">âš ï¸ æ˜¯å¦è¦å¯¼å‡ºæ‰€æœ‰è®°å½•å¹¶æ¸…ç©ºï¼Ÿæ“ä½œä¸å¯æ’¤é”€ã€‚</p>
    <button onclick="exportThenClear()" data-zh="âœ… ç¡®è®¤å¯¼å‡ºå¹¶æ¸…ç©º" data-en="âœ… Confirm Export & Clear">âœ… ç¡®è®¤å¯¼å‡ºå¹¶æ¸…ç©º</button>
    <button onclick="document.getElementById('confirm-clear-dialog').style.display='none'" data-zh="âŒ å–æ¶ˆ" data-en="âŒ Cancel">âŒ å–æ¶ˆ</button>
  </div>

  <footer>
    <hr>
    <small>å‚è€ƒäº†åŸç½‘é¡µhttps://stopwatch.online-timers.com/stopwatch-with-time-intervalsçš„åŠŸèƒ½ï¼Œç”± ChatGPT é‡æ–°ç¼–å†™ä»£ç å¹¶æ·»åŠ äº†ä¸ªæ€§åŒ–ä¿®æ”¹</small>
  </footer>

  <script>
    let currentLang = 'zh';
    function showTab(id) {
      document.querySelectorAll('.tab-content').forEach(div => div.style.display = 'none');
      document.getElementById(id).style.display = 'block';
    }
    function confirmExportAndClear() {
      document.getElementById('confirm-clear-dialog').style.display = 'block';
    }
    function exportThenClear() {
      exportIntervalsToCSV();
      intervals = [];
      localStorage.setItem('intervals', JSON.stringify(intervals));
      document.getElementById('intervals-container').innerHTML = '';
      document.getElementById('confirm-clear-dialog').style.display = 'none';
    }
    function toggleLang() {
      currentLang = currentLang === 'zh' ? 'en' : 'zh';
      document.querySelectorAll('[data-zh]').forEach(el => {
        el.textContent = el.getAttribute('data-' + currentLang);
      });
      document.getElementById('lang-toggle').textContent = currentLang === 'zh' ? 'ğŸŒ English' : 'ğŸŒ ä¸­æ–‡';
    }
    
  </script>
</body>
</html>
